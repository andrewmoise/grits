diff --git a/cmd/test-client/main.go b/cmd/test-client/main.go
index 3ac49ab..31191f7 100644
--- a/cmd/test-client/main.go
+++ b/cmd/test-client/main.go
@@ -1,10 +1,12 @@
 package main
 
 import (
-	"fmt"
+	"context"
 	"log"
 	"os"
+	"os/signal"
 	"path/filepath"
+	"syscall"
 	"time"
 
 	"grits/internal/proxy"
@@ -12,32 +14,21 @@ import (
 )
 
 func main() {
-	// Create two temporary directories for server data
-	tempDir1, err := os.MkdirTemp("", "grits_server1")
-	if err != nil {
-		log.Fatalf("Failed to create temp directory for server 1: %v", err)
-	}
-	defer os.RemoveAll(tempDir1)
-
+	// Create temporary directory for temp server data
 	tempDir2, err := os.MkdirTemp("", "grits_server2")
 	if err != nil {
 		log.Fatalf("Failed to create temp directory for server 2: %v", err)
 	}
 	defer os.RemoveAll(tempDir2)
 
-	// Create content directories in both temporary directories
-	contentDir1 := filepath.Join(tempDir1, "content")
-	if err := os.Mkdir(contentDir1, 0755); err != nil {
-		log.Fatalf("Failed to create content directory for server 1: %v", err)
-	}
-
+	// Create content directories for temp server
 	contentDir2 := filepath.Join(tempDir2, "content")
 	if err := os.Mkdir(contentDir2, 0755); err != nil {
 		log.Fatalf("Failed to create content directory for server 2: %v", err)
 	}
 
 	// Create a file in both content directories
-	filePath1 := filepath.Join(contentDir1, "testfile.txt")
+	filePath1 := filepath.Join("content", "testfile.txt")
 	if err := os.WriteFile(filePath1, []byte("hello"), 0644); err != nil {
 		log.Fatalf("Failed to write test file for server 1: %v", err)
 	}
@@ -49,12 +40,8 @@ func main() {
 
 	// Initialize and start the first server
 	config1 := proxy.NewConfig()
-	config1.ServerDir = tempDir1
+	config1.ServerDir = "."
 	config1.ThisPort = 1787
-	config1.DirMirrors = append(config1.DirMirrors, proxy.DirMirrorConfig{
-		SourceDir:     contentDir1,
-		CacheLinksDir: filepath.Join(tempDir1, "cache_links"),
-	})
 
 	srv1, err := server.NewServer(config1)
 	if err != nil {
@@ -88,14 +75,38 @@ func main() {
 	// Allow some time for servers to start
 	time.Sleep(2 * time.Second)
 
-	fileAddrStr, err := os.ReadFile(filepath.Join(tempDir1, "cache_links", "testfile.txt"))
+	fileAddrStr, err := os.ReadFile(filepath.Join(tempDir2, "cache_links", "testfile.txt"))
 	if err != nil {
 		log.Fatalf("Failed to read file address from server 1: %v", err)
 	}
 
 	log.Printf("File address from server 1: %s\n", fileAddrStr)
+	log.Printf("http://localhost:1787/grits/v1/sha256/%s\n", fileAddrStr)
+	log.Println("")
+	log.Println("Servers started. Proceed with manual testing.")
+
+	// Setup channel to listen for SIGINT and SIGTERM signals
+	signals := make(chan os.Signal, 1)
+	signal.Notify(signals, os.Interrupt, syscall.SIGTERM)
 
-	fmt.Println("Servers started. Proceed with manual testing.")
+	// Block until a signal is received
+	<-signals
+
+	log.Println("Signal received, shutting down servers...")
+
+	// Create a context with a timeout for server shutdown
+	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
+	defer cancel()
+
+	// Attempt to gracefully shut down server1
+	if err := srv1.Stop(ctx); err != nil {
+		log.Printf("Error shutting down server 1: %v\n", err)
+	}
+
+	// Attempt to gracefully shut down server2
+	if err := srv2.Stop(ctx); err != nil {
+		log.Printf("Error shutting down server 2: %v\n", err)
+	}
 
-	time.Sleep(360 * time.Second)
+	log.Println("Servers shut down successfully.")
 }
diff --git a/internal/server/server.go b/internal/server/server.go
index 857e2ba..ba8b462 100644
--- a/internal/server/server.go
+++ b/internal/server/server.go
@@ -68,15 +68,36 @@ func NewServer(config *proxy.Config) (*Server, error) {
 	return srv, nil
 }
 
+// corsMiddleware is a middleware function that adds CORS headers to the response.
+func corsMiddleware(handler http.HandlerFunc) http.HandlerFunc {
+	return func(w http.ResponseWriter, r *http.Request) {
+		w.Header().Set("Access-Control-Allow-Origin", "http://localhost:1787") // Or "*" for a public API
+		w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS")
+		w.Header().Set("Access-Control-Allow-Headers", "Content-Type")
+
+		// If it's an OPTIONS request, respond with OK status and return
+		if r.Method == "OPTIONS" {
+			w.WriteHeader(http.StatusOK)
+			return
+		}
+
+		handler(w, r)
+	}
+}
+
+// Then, apply this middleware to your handlers when setting up routes.
 func (s *Server) setupRoutes() {
 	s.Mux.HandleFunc("/grits/v1/sha256/", s.handleSHA256())
 	s.Mux.HandleFunc("/grits/v1/namespace/", s.handleNamespace())
 	s.Mux.HandleFunc("/grits/v1/root/", s.handleRoot())
 
-	// Ensure HTTPServer.Handler is set to use this Mux
-	s.HTTPServer.Handler = s.Mux
+	// Special handling for serving the Service Worker JS from the root
+	s.Mux.HandleFunc("/service-worker.js", func(w http.ResponseWriter, r *http.Request) {
+		http.ServeFile(w, r, s.Config.ServerPath("client/service-worker.js"))
+	})
 
-	s.Mux.Handle("/grits/v1/client/", http.StripPrefix("/grits/v1/client/", http.FileServer(http.Dir(s.Config.ServerPath("client")))))
+	// Handling client files with CORS enabled
+	s.Mux.Handle("/grits/v1/client/", http.StripPrefix("/grits/v1/client/", corsMiddleware(http.FileServer(http.Dir(s.Config.ServerPath("client"))).ServeHTTP)))
 }
 
 func (s *Server) Run() error {
